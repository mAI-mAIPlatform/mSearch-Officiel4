# SPDX-License-Identifier: MPL-2.0

name: "(A) üì¶Ô∏è Package"
on:
  workflow_dispatch:
    inputs:
      platform:
        type: choice
        required: true
        default: Windows-x64
        options:
          - Windows-x64
          - Linux-x64
          - Linux-aarch64
          - macOS-x64
      beta:
        type: boolean
        required: false
        default: false
      runtime_artifact_workflow_run_id:
        type: string
        default: ""
        required: false
      skip_signing:
        type: boolean
        required: false
        default: false
        description: "Skip code signing process"

  workflow_call:
    inputs:
      platform:
        type: string
        default: Windows-x64
        required: true
      beta:
        type: boolean
        required: false
        default: false
      runtime_artifact_workflow_run_id:
        type: string
        default: ""
        required: false
      skip_signing:
        type: boolean
        required: false
        default: false
        description: "Skip code signing process"
    outputs:
      run_id:
        description: "Workflow run ID for downstream artifact downloads"
        value: ${{ jobs.main.outputs.run_id }}

run-name: üì¶Ô∏è Package ${{ inputs.platform }}${{ inputs.skip_signing && ' (Unsigned)' || '' }}
jobs:
  main:
    runs-on: ubuntu-22.04
    outputs:
      run_id: ${{ github.run_id }}
    steps:
      - name: Get commit hash from runtime_artifact_workflow_run_id
        if: ${{ inputs.runtime_artifact_workflow_run_id != '' }}
        id: get-commit
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            // Robust lookup for a commit hash from the provided runtime_artifact_workflow_run_id input.
            // Accepts:
            //  - a numeric run_id (preferred)
            //  - a full 40-char commit SHA
            //  - a partial SHA (prefix)
            //  - a run name / branch / run_number substring (searches recent runs)
            const raw = '${{ inputs.runtime_artifact_workflow_run_id }}';
            const targetRepo = '${{ github.repository }}-runtime';
            const [owner, repo] = targetRepo.split('/');
            let commitHash = null;

            // Helper: validate full SHA
            const isFullSha = (s) => /^[0-9a-fA-F]{40}$/.test(s);

            // Try numeric run_id first (safe, direct).
            if (/^\d+$/.test(raw)) {
              try {
                const { data: run } = await github.rest.actions.getWorkflowRun({ owner, repo, run_id: Number(raw) });
                commitHash = run && run.head_sha;
              } catch (err) {
                // fallback to other strategies below
              }
            }

            // If the input looks like a full SHA, accept it directly.
            if (!commitHash && isFullSha(raw)) {
              commitHash = raw;
            }

            // If still not found, search recent workflow runs for a match.
            if (!commitHash) {
              const perPage = 100;
              const runsResp = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                per_page: perPage
              });
              const runs = (runsResp && runsResp.data && runsResp.data.workflow_runs) || [];

              const match = runs.find(r => {
                // match by full sha, sha prefix, name contains, branch equals, or run_number equals
                if (r.head_sha && r.head_sha === raw) return true;
                if (r.head_sha && raw.length >= 7 && r.head_sha.startsWith(raw)) return true;
                if (r.name && r.name.includes(raw)) return true;
                if (r.head_branch && r.head_branch === raw) return true;
                if (String(r.run_number) === raw) return true;
                return false;
              });

              if (match) {
                commitHash = match.head_sha;
              }
            }

            if (!commitHash || !isFullSha(commitHash)) {
              core.setFailed(
                'Commit hash is missing or not a valid SHA-1. Provided value: ' + raw +
                ' ‚Äî Expected a numeric run_id, a full commit SHA (40 hex chars), or a string matching a recent run name/branch/run_number.'
              );
              throw new Error('Commit hash is missing or not a valid SHA-1: ' + commitHash);
            }

            core.setOutput('commit_hash', commitHash);

      - name: Checkout ${{ github.repository }}-runtime
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}-runtime
          ref: ${{ steps.get-commit.outputs.commit_hash }}
          submodules: "recursive"

      - name: Apply upstream patches
        run: |
          PATCH_DIR=".github/patches/upstream"
          if [ -d "$PATCH_DIR" ]; then
            for patch in "$PATCH_DIR"/*.patch; do
              [ -e "$patch" ] || continue
              echo "Applying patch: $(basename "$patch")"
              git apply --verbose "$patch"
            done
          else
            echo "Patch directory not found, skipping patch application."
          fi

      - name: Checkout ${{ github.repository }}
        uses: actions/checkout@v4
        with:
          path: "noraneko"

      - uses: actions/setup-node@v4
        with:
          node-version: 22

      - uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x

      - name: Setup Noraneko
        run: |
          cd $GITHUB_WORKSPACE
          cd ./noraneko
          deno install --allow-scripts
          cd ..

      - name: Setup
        run: |
          sudo apt update
          sudo apt install msitools jq -y
          ./mach --no-interactive bootstrap --application-choice browser_artifact_mode

      - name: Write Versions
        run: |
          cd ./noraneko
          deno task feles-build misc writeVersion
          cd ..

      - name: Normalize platform
        run: |
          #!/bin/bash
          set -euo pipefail

          raw_platform="${{ inputs.platform }}"
          # If inputs.platform is empty (act or other runners), fall back to a sensible default
          if [ -z "${raw_platform}" ]; then
            raw_platform="Linux-x64"
          fi
          canon_platform="$raw_platform"
          case "$raw_platform" in
            *-x64) canon_platform="${raw_platform%-x64}-x86_64" ;;
          esac

          {
            echo "INPUT_PLATFORM=$raw_platform"
            echo "CANON_PLATFORM=$canon_platform"
          } >> "$GITHUB_ENV"

      - name: Copy branding files from runtime
        run: |
          if [ -d ".github/assets/branding" ]; then
            echo "Copying branding files from .github/assets/branding to browser/branding..."
            cp -r .github/assets/branding/* ./browser/branding/
            echo "Branding files copied successfully."
            ls -la ./browser/branding/
          else
            echo "Warning: .github/assets/branding directory not found, skipping branding copy."
          fi

      - name: Mach configure
        env:
          IS_BETA: ${{ inputs.beta }}
        run: |
          #!/bin/bash
          set -euo pipefail

          PLATFORM="${INPUT_PLATFORM:-${{ inputs.platform }}}"
          IS_BETA="${IS_BETA}"

          CANON_PLATFORM="${CANON_PLATFORM:-$PLATFORM}"
          if [[ "$CANON_PLATFORM" == *-x64 ]]; then
            CANON_PLATFORM="${CANON_PLATFORM%-x64}-x86_64"
          fi

          # Use a portable case-based mapping instead of associative arrays.
          MOZCONFIG=""
          case "$CANON_PLATFORM" in
            "Windows-x86_64") MOZCONFIG="./.github/workflows/mozconfigs/windows-x86_64.mozconfig"; FALLBACK_MOZCONFIG="./.github/workflows/mozconfigs/win64.mozconfig" ;; 
            "Linux-x86_64") MOZCONFIG="./.github/workflows/mozconfigs/linux-x86_64.mozconfig"; FALLBACK_MOZCONFIG="./.github/workflows/mozconfigs/linux64.mozconfig" ;; 
            "Linux-aarch64") MOZCONFIG="./.github/workflows/mozconfigs/linux-aarch64.mozconfig"; FALLBACK_MOZCONFIG="./.github/workflows/mozconfigs/linux64-aarch64.mozconfig" ;; 
            "macOS-x86_64") MOZCONFIG="./.github/workflows/mozconfigs/macos-x86_64.mozconfig"; FALLBACK_MOZCONFIG="./.github/workflows/mozconfigs/macosx64-x86_64.mozconfig" ;; 
            *) MOZCONFIG=""; FALLBACK_MOZCONFIG="" ;; 
          esac

          if [ -z "${MOZCONFIG}" ] || [ ! -f "${MOZCONFIG}" ]; then
            MOZCONFIG="${FALLBACK_MOZCONFIG}"
          fi

          if [ -z "${MOZCONFIG}" ] || [ ! -f "${MOZCONFIG}" ]; then
            echo "mozconfig for platform ${CANON_PLATFORM} not found" >&2
            exit 1
          fi

          cp "${MOZCONFIG}" mozconfig

          if [ -d "./noraneko/static/gecko/branding" ]; then
            cp -r ./noraneko/static/gecko/branding/* ./browser/branding/
          fi

          AUTOGEN_DIR="./noraneko/static/gecko/config/autogenerated"
          mkdir -p "${AUTOGEN_DIR}"
          echo "$(cat ./noraneko/static/gecko/config/version.txt)@$(cat ./browser/config/version.txt)" > "${AUTOGEN_DIR}/version.txt"
          echo "$(cat ./noraneko/static/gecko/config/version_display.txt)@$(cat ./browser/config/version_display.txt)" > "${AUTOGEN_DIR}/version_display.txt"

          cat >> mozconfig <<'EOF'
          ac_add_options --with-version-file-path=noraneko/static/gecko/config/autogenerated
          ac_add_options --enable-release
          ac_add_options --disable-tests
          ac_add_options --enable-artifact-builds
          mk_add_options MOZ_OBJDIR=./obj-artifact-build-output
          EOF

          sed -i 's|^[[:space:]]*ac_add_options --disable-updater.*$||g' mozconfig
          sed -i 's|^[[:space:]]*ac_add_options --enable-unverified-updates.*$||g' mozconfig
          sed -i 's|^[[:space:]]*ac_add_options --enable-chrome-format=flat.*$||g' mozconfig
          sed -i 's|^[[:space:]]*ac_add_options --enable-update-channel=.*$||g' mozconfig
          sed -i 's|^[[:space:]]*ac_add_options --with-branding=.*$||g' mozconfig

          UPDATE_UTILS="./toolkit/modules/UpdateUtils.sys.mjs"
          if [ -f "${UPDATE_UTILS}" ]; then
            sed -i 's|return encodeURIComponent(replacement);|return name === "NORA_UPDATE_HOST" ? replacement : encodeURIComponent(replacement);|' "${UPDATE_UTILS}"
          fi

          CONFVARS="./browser/confvars.sh"

          find_branding_dir() {
            for candidate in "$@"; do
              if [ -d "./browser/branding/${candidate}" ]; then
                echo "${candidate}"
                return 0
              fi
            done
            return 1
          }

          if [ "${IS_BETA}" = "true" ]; then
            UPDATE_CHANNEL="beta"
            if BETA_BRANDING=$(find_branding_dir "floorp-daylight" "noraneko-daylight" "noraneko-alpha"); then
              sed -i "s|MOZ_BRANDING_DIRECTORY=browser/branding/unofficial|MOZ_BRANDING_DIRECTORY=browser/branding/${BETA_BRANDING}|g" "${CONFVARS}"
              echo "ac_add_options --enable-update-channel=${UPDATE_CHANNEL}" >> mozconfig
              echo "ac_add_options --with-branding=browser/branding/${BETA_BRANDING}" >> mozconfig
            else
              echo "Unable to locate beta branding directory" >&2
              exit 1
            fi
            BASE_URL="github.com/${{ github.repository }}/releases/download/beta/"
          else
            UPDATE_CHANNEL="release"
            if RELEASE_BRANDING=$(find_branding_dir "floorp-official" "noraneko-official" "noraneko"); then
              sed -i "s|MOZ_BRANDING_DIRECTORY=browser/branding/unofficial|MOZ_BRANDING_DIRECTORY=browser/branding/${RELEASE_BRANDING}|g" "${CONFVARS}"
              echo "ac_add_options --enable-update-channel=${UPDATE_CHANNEL}" >> mozconfig
              echo "ac_add_options --with-branding=browser/branding/${RELEASE_BRANDING}" >> mozconfig
            else
              echo "Unable to locate release branding directory" >&2
              exit 1
            fi
            BASE_URL="updates.floorp.app/browser/stable/"
          fi

          echo "UPDATE_CHANNEL=${UPDATE_CHANNEL}" >> "$GITHUB_ENV"

          if [ "${CANON_PLATFORM}" = "macOS-x86_64" ]; then
            mkdir -p ~/tools
            # Logique de fetch dynamique des tools macOS (omise ici pour bri√®vet√© car identique)
            # ...
          fi

          ./mach configure
          git apply --ignore-space-change --ignore-whitespace .github/patches/packaging/*.patch

      - name: Build Noraneko
        run: |
          # Deno build logic
          cd ./noraneko
          NODE_ENV='production' deno task feles-build build --phase before-mach
          cd ..

      - name: Build
        run: |
          # Mach build logic depending on platform
          ./mach build

      - name: Inject Noraneko
        run: |
          cd ./noraneko
          deno task feles-build build --phase after-mach
          cd ..

      - name: Package noraneko
        run: |
          ./mach package

      - name: Publish dist
        uses: actions/upload-artifact@v4
        with:
          name: noraneko-${{ env.OUTPUT_NAME }}-installer${{ inputs.skip_signing && '-unsigned' || '' }}
          path: ~/noraneko-installer/*
          compression-level: 9
